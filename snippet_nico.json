{
"ForLoop": {
"prefix": "for",
"description": "Iterates with max counter",
"body": [
"for (var i = 0; i < ${1:counter}; i++) {",
"// Code...",
"}"
]
},
"ForInLoop": {
"prefix": "for in",
"description": "Iterates over data list",
"body": [
"for (var item in ${1:iterable}) {",
"  // Code...",
"}"
]
},
"mockDioWhen": {
"prefix": "mockDio When",
"description": "Iterates over data list",
"body": [
" when(",
"  mockDio.post(",
"   queryRoute,",
"     data: anyNamed('data'),",
"    queryParameters: anyNamed(\"queryParameters\"),",
"     options: anyNamed(\"options\"),",
"  ),",
"   ).thenAnswer(",
"   (_) async => Response(",
"  requestOptions: RequestOptions(path: queryRoute),",
"    data: expectedData,",
"  statusCode: 200,",
" ),",
" );"
]
},
"mockDioExpectedDataWhen": {
"prefix": "mockDio ExpectedData When",
"description": "Iterates over data list",
"body": [
"final expectedData = {",
"  \"data\":[],",
" \"meta\": generateMockMeta(total: 3).toJson(),",
"      };",
"",
" when(",
"  mockDio.post(",
"   queryRoute,",
"     data: anyNamed('data'),",
"    queryParameters: anyNamed(\"queryParameters\"),",
"     options: anyNamed(\"options\"),",
"  ),",
"   ).thenAnswer(",
"   (_) async => Response(",
"  requestOptions: RequestOptions(path: queryRoute),",
"    data: expectedData,",
"  statusCode: 200,",
" ),",
" );"
]
},
"GenerateMockForEntity": {
"prefix": "generateMockForEntity",
"description": "Generates a list of mocked Class instances using faker",
"body": [
"import 'package:faker/faker.dart';",
"",
"List<${1:ClassName}> generateMock${1:ClassName}List(int count) {",
"  return List.generate(count, (index) {",
"    return generateMock${1:ClassName}(id: index);",
"  });",
"}",
"",
"${1:ClassName} generateMock${1:ClassName}({int id = 1}) {",
"  Faker faker = Faker.withGenerator(RandomGenerator(seed: id));",
"",
"  return ${1:ClassName}.empty().copyWith(",
"    firstName: faker.person.firstName(),",
"    lastName: faker.person.lastName(),",
"    email: faker.internet.email(),",
"  );",
"}"
]
},
"tryCatchFinally": {
"prefix": "try",
"description": "try catch with Sentry exception and a finally block",
"body": [
"   try {",
"",
" } catch (exception, stackTrace) {",
" Sentry.captureException(exception, stackTrace: stackTrace);",
" } finally {",
"",
" }"
]
},
"WidgetTestFile": {
"prefix": "widgetTest",
"description": "Create the skeleton of a widget test file",
"body": []
},
"UnitTestFileWithDioMock": {
"prefix": "unitTestWithDioMock",
"description": "Create the skeleton of a unit test file for a controller with dio and dioService mocked",
"body": [
"import 'package:connectivity_plus/connectivity_plus.dart';",
"import 'package:flutter_test/flutter_test.dart';",
"import 'package:get/get_navigation/get_navigation.dart';",
"import 'package:get/instance_manager.dart';",
"import 'package:dio/dio.dart';",
"import 'package:mockito/annotations.dart';",
"import 'package:mockito/mockito.dart';",
"",
"import '${TM_FILENAME_BASE}.mocks.dart';",
"",
"@GenerateNiceMocks([MockSpec<Dio>(), MockSpec<Connectivity>()])",
"void main() {",
"  TestWidgetsFlutterBinding.ensureInitialized();",
"",
"  late ${2:TestControllerClass} controller;",
"  late Connectivity mockConnectivity;",
"  late Dio mockDio;",
"  late MockDioService dioService;",
"",
"  setUpAll(() {",
"    Get.testMode = true;",
"",
"    mockDio = MockDio();",
"    dioService = MockDioService(mockDio);",
"    Get.put(mockDio, tag: 'congesClient');",
"",
"   mockConnectivity = MockConnectivity();",
"   Get.put<Connectivity>(mockConnectivity);",
"   when(",
"     mockConnectivity.checkConnectivity(),",
"   ).thenAnswer((_) async => [ConnectivityResult.wifi]);",
"",
"    controller = ${2:TestControllerClass}();",
"  });",
"",
"  group('name of the tested function', () {",
"",
"    String queryRoute = '/v1/clients/open-days';",
"",
"    setUp(() {",
"      // Reset all parameters between tests in this group",
"    });",
"",
"    test('  (Nominal Case)', () async {",
"final expectedData = [1, 2, 3, 4, 5];",
"dioService.mockResponse(",
"typeOfRequest: TypeOfRequest.get,",
"route: queryRoute,",
"result: {\"data\": expectedData},",
");",
"final result = await controller.method();",
"expect(result.fold((l) => null, (r) => r), expectedData);",
"    });",
"  });",
"}"
]
},
"ClassAndDto": {
"prefix": "dtoEntityMapper",
"description": "Create an Entity with it DTO and it Mapper",
"body": [
"import 'package:freezed_annotation/freezed_annotation.dart';",
"",
"// Used by the entity class and the DTO class",
"part '${TM_FILENAME_BASE}.freezed.dart';",
"",
"// Used by the DTO class",
"part '${TM_FILENAME_BASE}.g.dart';",
"",
"// ****************************************",
"// After you created this snippet, use this command in the terminal to generate the missing file with freezed",
"//",
"// ->>>  dart run build_runner watch -d",
"//",
"// When the files are generated, you can delete this comment",
"// ****************************************",
"",
"// ****************************************",
"//  ${1:ClassName} Entity",
"// ****************************************",
"",
"@freezed",
"class ${1:ClassName} with _\\$${1:ClassName} {",
"  @override",
"  final attribute1Type ${2:attribute1};",
"  final attribute2Type ${3:attribute2};",
"  final attribute3Type ${4:attribute3};",
"  final attribute4Type ${5:attribute4};",
"  final attribute5Type ${6:attribute5};",
"  final attribute6Type ${7:attribute6};",
"  final attribute7Type ${8:attribute7};",
"  final attribute8Type ${9:attribute8};",
"  final attribute9Type ${10:attribute9};",
"  final attribute10Type ${11:attribute10};",
"",
"  const ${1:ClassName}._({",
"    required this.${2:attribute1},",
"    required this.${3:attribute2},",
"    required this.${4:attribute3},",
"    required this.${5:attribute4},",
"    required this.${6:attribute5},",
"    required this.${7:attribute6},",
"    required this.${8:attribute7},",
"    required this.${9:attribute8},",
"    required this.${10:attribute9},",
"    required this.${11:attribute10},",
"  });",
"",
"  const factory ${1:ClassName}({",
"    required attribute1Type ${2:attribute1},",
"    required attribute2Type ${3:attribute2},",
"    required attribute3Type ${4:attribute3},",
"    required attribute4Type ${5:attribute4},",
"    required attribute5Type ${6:attribute5},",
"    required attribute6Type ${7:attribute6},",
"    required attribute7Type ${8:attribute7},",
"    required attribute8Type ${9:attribute8},",
"    required attribute9Type ${10:attribute9},",
"    required attribute10Type ${11:attribute10},",
"  }) = _${1:ClassName};",
"",
"  factory ${1:ClassName}.empty() {",
"    return ${1:ClassName}(",
"      ${2:attribute1}: 0,",
"      ${3:attribute2}: 0,",
"      ${4:attribute3}: 0,",
"      ${5:attribute4}: 0,",
"      ${6:attribute5}: 0,",
"      ${7:attribute6}: 0,",
"      ${8:attribute7}: 0,",
"      ${9:attribute8}: 0,",
"      ${10:attribute9}: 0,",
"      ${11:attribute10}: 0,",
"    );",
"  }",
"",
"  factory ${1:ClassName}.fromDto(${1:ClassName}Dto dto) => ${1:ClassName}Mapper.fromDTO(dto);",
"}",
"",

"// ****************************************",
"//  ${1:ClassName} DTO",
"// ****************************************",
"",
"@freezed",
"abstract class ${1:ClassName}Dto with _\\$${1:ClassName}Dto {",
"  const factory ${1:ClassName}Dto({",
"    @JsonKey(name: '${2:attribute1}') attribute1Type? ${2:attribute1},",
"    @JsonKey(name: '${3:attribute2}') attribute2Type? ${3:attribute2},",
"    @JsonKey(name: '${4:attribute3}') attribute3Type? ${4:attribute3},",
"    @JsonKey(name: '${5:attribute4}') attribute4Type? ${5:attribute4},",
"    @JsonKey(name: '${6:attribute5}') attribute5Type? ${6:attribute5},",
"    @JsonKey(name: '${7:attribute6}') attribute6Type? ${7:attribute6},",
"    @JsonKey(name: '${8:attribute7}') attribute7Type? ${8:attribute7},",
"    @JsonKey(name: '${9:attribute8}') attribute8Type? ${9:attribute8},",
"    @JsonKey(name: '${10:attribute9}') attribute9Type? ${10:attribute9},",
"    @JsonKey(name: '${11:attribute10}') attribute10Type? ${11:attribute10},",
"  }) = _${1:ClassName}Dto;",
"",
"  factory ${1:ClassName}Dto.fromEntity(${1:ClassName} entity) => ${1:ClassName}Mapper.toDTO(entity);",
"",
"  factory ${1:ClassName}Dto.fromJson(Map<String, dynamic> json) =>",
"      _\\$${1:ClassName}DtoFromJson(json);",
"}",
"",

"// ****************************************",
"//  ${1:ClassName} MAPPER",
"// ****************************************",
"",
"class ${1:ClassName}Mapper {",
"  static ${1:ClassName} fromDTO(${1:ClassName}Dto dto) {",
"    return ${1:ClassName}(",
"      ${2:attribute1}: dto.${2:attribute1} ?? 0,",
"      ${3:attribute2}: dto.${3:attribute2} ?? 0,",
"      ${4:attribute3}: dto.${4:attribute3} ?? 0,",
"      ${5:attribute4}: dto.${5:attribute4} ?? 0,",
"      ${6:attribute5}: dto.${6:attribute5} ?? 0,",
"      ${7:attribute6}: dto.${7:attribute6} ?? 0,",
"      ${8:attribute7}: dto.${8:attribute7} ?? 0,",
"      ${9:attribute8}: dto.${9:attribute8} ?? 0,",
"      ${10:attribute9}: dto.${10:attribute9} ?? 0,",
"      ${11:attribute10}: dto.${11:attribute10} ?? 0,",
"    );",
"  }",
"",
"  static ${1:ClassName}Dto toDTO(${1:ClassName} entity) {",
"    return ${1:ClassName}Dto(",
"      ${2:attribute1}: entity.${2:attribute1},",
"      ${3:attribute2}: entity.${3:attribute2},",
"      ${4:attribute3}: entity.${4:attribute3},",
"      ${5:attribute4}: entity.${5:attribute4},",
"      ${6:attribute5}: entity.${6:attribute5},",
"      ${7:attribute6}: entity.${7:attribute6},",
"      ${8:attribute7}: entity.${8:attribute7},",
"      ${9:attribute8}: entity.${9:attribute8},",
"      ${10:attribute9}: entity.${10:attribute9},",
"      ${11:attribute10}: entity.${11:attribute10},",
"    );",
"  }",
"}"
]
},
"FakeRepositorySingleton": {
"prefix": "fakeRepository",
"description": "Singleton FakeRepository with in-memory fake database",
"body": [
"import '../../domain/entity/${2:ClassNameWithoutMaj}/${2:ClassNameWithoutMaj}.dart';",
"import '../model/${2:ClassNameWithoutMaj}_dto/${2:ClassNameWithoutMaj}_dto.dart';",
"",
"class ${1:ClassName}Repository {",
"  ${1:ClassName}Repository._internal();",
"  static final ${1:ClassName}Repository _singleton = ${1:ClassName}Repository._internal();",
"  factory ${1:ClassName}Repository() {",
"    return _singleton;",
"  }",
"",
"  final List<${1:ClassName}Dto> _fakeDatabase = [];",
"",
"  void add${1:ClassName}(${1:ClassName} ${2:ClassNameWithoutMaj}) {",
"    _fakeDatabase.add(${1:ClassName}Dto.fromEntity(${2:ClassNameWithoutMaj}));",
"  }",
"",
"  bool remove${1:ClassName}(${1:ClassName} ${2:ClassNameWithoutMaj}) {",
"    if (_fakeDatabase.any((${2:ClassNameWithoutMaj}Dto) => ${2:ClassNameWithoutMaj}Dto.id == ${2:ClassNameWithoutMaj}.id)) {",
"      return _fakeDatabase.remove(",
"        _fakeDatabase.firstWhere((${2:ClassNameWithoutMaj}Dto) => ${2:ClassNameWithoutMaj}Dto.id == ${2:ClassNameWithoutMaj}.id),",
"      );",
"    } else {",
"      return false;",
"    }",
"  }",
"",
"  ${1:ClassName}? get${1:ClassName}ById(int ${2:ClassNameWithoutMaj}Id) {",
"    if (_fakeDatabase.any((${2:ClassNameWithoutMaj}) => ${2:ClassNameWithoutMaj}.id == ${2:ClassNameWithoutMaj}Id)) {",
"      return ${1:ClassName}.fromDto(",
"        _fakeDatabase.firstWhere((${2:ClassNameWithoutMaj}) => ${2:ClassNameWithoutMaj}.id == ${2:ClassNameWithoutMaj}Id),",
"      );",
"    }",
"    return null;",
"  }",
"",
"  List<${1:ClassName}> getAll${1:ClassName}() {",
"    return _fakeDatabase.map((${2:ClassNameWithoutMaj}Dto) => ${1:ClassName}.fromDto(${2:ClassNameWithoutMaj}Dto)).toList();",
"  }",
"}"
]
}
}
